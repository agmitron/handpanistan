<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch</title>
</head>

<body>
    <audio controls src="./Kuckhermann-Nadishana-Metz  Sound of Viborg  (hang, bawu, ba.m4a"></audio>
    <script>
        async function init() {
            const audioContext = new window.AudioContext();
            const micStream = await window.navigator.mediaDevices.getUserMedia({ audio: true })

            console.log({ audioContext })

            const analyserAudioNode = audioContext.createAnalyser();
            analyserAudioNode.fftSize = 2048;

            // micStream is the MediaStream object we get from the Media Stream API
            const sourceAudioNode = audioContext.createMediaStreamSource(micStream);
            sourceAudioNode.connect(analyserAudioNode); // See initialization in the AnalyserNode section of the demo.

            pitch(analyserAudioNode, audioContext.sampleRate);

            addEventListener('pitch', e => {
                const freq = e.detail.frequency
            })
        }

        function pitch(analyserAudioNode, rate) {
            const buffer = new Uint8Array(analyserAudioNode.fftSize);
            analyserAudioNode.getByteTimeDomainData(buffer);
            const fundFreq = findFundamentalFrequency(buffer, rate)

            if (fundFreq !== -1) {
                const pitchEvent = new CustomEvent('pitch', {
                    detail: {
                        frequency: fundFreq
                    }
                })

                dispatchEvent(pitchEvent)
            }

            requestAnimationFrame(() => pitch(analyserAudioNode, rate))
        }

        function findFundamentalFrequency(buffer, sampleRate) {
            // Мы будем использовать автокорреляцию для поиска основной частоты

            // Для корреляции сигнала самим собой (отсюда и название алгоритма), мы проверим две точки на расстоянии k. 
            // Индекс автокорреляции будет средним значением для этих сумм. At the same time, we normalize the values.
            // Источник: http://www.phy.mty.edu/~suits/autocorrelation.html
            // Предполагая, что частота дискредизации составляет 48000Hz, значение 'k' равное 1000 будет соответствовать сигналу в 48Hz (48000/1000 = 48), 
            // в то время как 'k' равное 8 будет соответствовать 6000Hz, чего более чем достаточно для покрытия большей части частот (если не всех) 
            let n = 1024, bestR = 0, bestK = -1;
            for (let k = 8; k <= 1000; k++) {
                let sum = 0;

                for (let i = 0; i < n; i++) {
                    sum += ((buffer[i] - 128) / 128) * ((buffer[i + k] - 128) / 128);
                }

                if (sum > 0) {
                    console.log({sum})
                }

                let r = sum / (n + k);

                if (r > bestR) {
                    bestR = r;
                    bestK = k;
                }

                console.log({r})

                if (r > 0.9) {
                    // Предполагаем, что этого достаточно и останавливаемся. 
                    break;
                }
            }

            if (bestR > 0.0025) {
                // bestK - отрезок основной частоты.
                let fundamentalFreq = sampleRate / bestK;
                return fundamentalFreq;
            }
            else {
                // Не найдено хорошей корреляции
                return -1;
            }
        }

        document.addEventListener('click', init)
    </script>
</body>

</html>